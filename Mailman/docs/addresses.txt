Email addresses
===============

Addresses represent a text email address, along with some meta data about
those addresses, such as their registration date, and whether and when they've
been validated.  Addresses may be linked to the users that Mailman knows
about.  Addresses are subscribed to mailing lists though members.

    >>> from Mailman.database import flush
    >>> from Mailman.configuration import config
    >>> mgr = config.user_manager


Creating addresses
------------------

Addresses are created directly through the user manager, which starts out with
no addresses.

    >>> sorted(address.address for address in mgr.addresses)
    []

Creating an unlinked email address is straightforward.

    >>> address_1 = mgr.create_address('aperson@example.com')
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['aperson@example.com']

However, such addresses have no real name.

    >>> address_1.real_name
    ''

You can also create an email address object with a real name.

    >>> address_2 = mgr.create_address('bperson@example.com', 'Ben Person')
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['aperson@example.com', 'bperson@example.com']
    >>> sorted(address.real_name for address in mgr.addresses)
    ['', 'Ben Person']

You can assign real names to existing addresses.

    >>> address_1.real_name = 'Anne Person'
    >>> flush()
    >>> sorted(address.real_name for address in mgr.addresses)
    ['Anne Person', 'Ben Person']

These addresses are not linked to users, and can be seen by searching the user
manager for an associated user.

    >>> print mgr.get_user('aperson@example.com')
    None
    >>> print mgr.get_user('bperson@example.com')
    None

You can create email addresses that are linked to users by using a different
interface.

    >>> user_1 = mgr.create_user('cperson@example.com', 'Claire Person')
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['aperson@example.com', 'bperson@example.com', 'cperson@example.com']
    >>> sorted(address.real_name for address in mgr.addresses)
    ['Anne Person', 'Ben Person', 'Claire Person']

And now you can find the associated user.

    >>> print mgr.get_user('aperson@example.com')
    None
    >>> print mgr.get_user('bperson@example.com')
    None
    >>> mgr.get_user('cperson@example.com')
    <User "Claire Person" at ...>


Deleting addresses
------------------

You can remove an unlinked address from the usre manager.

    >>> mgr.delete_address(address_1)
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['bperson@example.com', 'cperson@example.com']
    >>> sorted(address.real_name for address in mgr.addresses)
    ['Ben Person', 'Claire Person']

Deleting a linked address does not delete the user, but it does unlink the
address from the user.

    >>> sorted(address.address for address in user_1.addresses)
    ['cperson@example.com']
    >>> user_1.controls('cperson@example.com')
    True
    >>> address_3 = list(user_1.addresses)[0]
    >>> mgr.delete_address(address_3)
    >>> flush()
    >>> sorted(address.address for address in user_1.addresses)
    []
    >>> user_1.controls('cperson@example.com')
    False
    >>> sorted(address.address for address in mgr.addresses)
    ['bperson@example.com']


Registration and validation
---------------------------

Addresses have two dates, the date the address was registered on and the date
the address was validated on.  Neither date is set by default.

    >>> address_4 = mgr.create_address('dperson@example.com', 'Dan Person')
    >>> flush()
    >>> print address_4.registered_on
    None
    >>> print address_4.validated_on
    None

The registered date takes a Python datetime object.

    >>> from datetime import datetime
    >>> address_4.registered_on = datetime(2007, 5, 8, 22, 54, 1)
    >>> flush()
    >>> print address_4.registered_on
    2007-05-08 22:54:01
    >>> print address_4.validated_on
    None

And of course, you can also set the validation date.

    >>> address_4.validated_on = datetime(2007, 5, 13, 22, 54, 1)
    >>> flush()
    >>> print address_4.registered_on
    2007-05-08 22:54:01
    >>> print address_4.validated_on
    2007-05-13 22:54:01


Subscriptions
-------------

Addresses get subscribed to mailing lists, not users.  When the address is
subscribed, a role is specified.

    >>> address_5 = mgr.create_address('eperson@example.com', 'Elly Person')
    >>> mlist = config.list_manager.create('_xtext@example.com')
    >>> from Mailman.constants import MemberRole
    >>> address_5.subscribe(mlist, MemberRole.owner)
    <Member: Elly Person <eperson@example.com> on
             _xtext@example.com as MemberRole.owner>
    >>> address_5.subscribe(mlist, MemberRole.member)
    <Member: Elly Person <eperson@example.com> on
             _xtext@example.com as MemberRole.member>
    >>> flush()

Now that Elly is both an owner and a member of the mailing list.

    >>> sorted(mlist.owners.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.owner>]
    >>> sorted(mlist.moderators.members)
    []
    >>> sorted(mlist.administrators.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.owner>]
    >>> sorted(mlist.members.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.member>]
    >>> sorted(mlist.regular_members.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.member>]
    >>> sorted(mlist.digest_members.members)
    []


Clean up
--------

    >>> for mlist in config.list_manager.mailing_lists:
    ...     config.list_manager.delete(mlist)
    >>> for user in mgr.users:
    ...     mgr.delete_user(user)
    >>> for address in mgr.addresses:
    ...     mgr.delete_address(address)
    >>> flush()
    >>> sorted(config.list_manager.names)
    []
    >>> sorted(mgr.users)
    []
    >>> sorted(mgr.addresses)
    []
