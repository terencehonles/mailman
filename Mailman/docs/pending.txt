The pending database
====================

The pending database is where various types of events which need confirmation
are stored.  These can include email address registration events, held
messages (but only for user confirmation), auto-approvals, and probe bounces.
This is not where messages held for administrator approval are kept.

    >>> from Mailman.configuration import config
    >>> from Mailman.database import flush
    >>> from Mailman.interfaces import IPendable, IPending
    >>> from zope.interface import implements
    >>> from zope.interface.verify import verifyObject

In order to pend an event, you first need a pending database, which is
available by adapting the list manager.

    >>> pendingdb = IPending(config.db)
    >>> verifyObject(IPending, pendingdb)
    True

The pending database can add any IPendable to the database, returning a token
that can be used in urls and such.

    >>> class SimplePendable(dict):
    ...     implements(IPendable)
    >>> subscription = SimplePendable(
    ...     type='subscription',
    ...     address='aperson@example.com',
    ...     realname='Anne Person',
    ...     language='en',
    ...     password='xyz')
    >>> token = pendingdb.add(subscription)
    >>> flush()
    >>> len(token)
    40

There's not much you can do with tokens except to 'confirm' them, which
basically means returning the IPendable structure (as a dict) from the
database that matches the token.  If the token isn't in the database, None is
returned.

    >>> pendable = pendingdb.confirm('missing')
    >>> print pendable
    None
    >>> pendable = pendingdb.confirm(token)
    >>> flush()
    >>> sorted(pendable.items())
    [('address', 'aperson@example.com'),
     ('language', 'en'),
     ('password', 'xyz'),
     ('realname', 'Anne Person'),
     ('type', 'subscription')]

After confirmation, the token is no longer in the database.

    >>> pendable = pendingdb.confirm(token)
    >>> print pendable
    None

There are a few other things you can do with the pending database.  When you
confirm a token, you can leave it in the database, or in otherwords, not
expunge it.

    >>> event_1 = SimplePendable(type='one')
    >>> token_1 = pendingdb.add(event_1)
    >>> event_2 = SimplePendable(type='two')
    >>> token_2 = pendingdb.add(event_2)
    >>> event_3 = SimplePendable(type='three')
    >>> token_3 = pendingdb.add(event_3)
    >>> flush()
    >>> pendable = pendingdb.confirm(token_1, expunge=False)
    >>> flush()
    >>> pendable.items()
    [('type', 'one')]
    >>> pendable = pendingdb.confirm(token_1, expunge=True)
    >>> flush()
    >>> pendable.items()
    [('type', 'one')]
    >>> pendable = pendingdb.confirm(token_1)
    >>> flush()
    >>> print pendable
    None

An event can be given a lifetime when it is pended, otherwise it just uses a
default lifetime.

    >>> from datetime import timedelta
    >>> yesterday = timedelta(days=-1)
    >>> event_4 = SimplePendable(type='four')
    >>> token_4 = pendingdb.add(event_4, lifetime=yesterday)
    >>> flush()

Every once in a while the pending database is cleared of old records.

    >>> pendingdb.evict()
    >>> flush()
    >>> pendable = pendingdb.confirm(token_4)
    >>> print pendable
    None
    >>> pendable = pendingdb.confirm(token_2)
    >>> pendable.items()
    [('type', 'two')]
    >>> flush()
