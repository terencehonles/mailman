#! /usr/bin/env python
#
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Partition a mass delivery into a suitable set of subdeliveries."""

# Heh, heh, heh, this partition reminds me of the knapsack problem ;-)
# Ie, the optimal distribution here is NP Complete.

import os

if not os.fork():
    import string, sys, regsub
    import paths
    import mm_cfg
    def ContactTransport(sender, recip, filename):
	os.execv(os.path.join(os.path.join(paths.prefix,"mail"),
	                                     "contact_transport")
                                         [sender,tmp_file]+to_addrs)

    domain_info = {}
    def GroupByDomain(addr):
        "Collect addrs by major subdomain - e.g. the 'python' in python.org."
	parts = regsub.split(addr, '[.@]')
	key = string.join(parts[-2:])
        addr = repr(addr)
	if not domain_info.has_key(key):
	    domain_info[key] = [addr]
	else:
	    domain_info[key].append(addr)

    def BuildGroups(biglist, num_addrs):
	biglist.sort(lambda x,y: len(x) < len(y))
	groups = []
	for i in range(spawns-1):
	    target_size = num_addrs / (spawns - i)
	    if not len(biglist):
		break
	    newlist = biglist[0]
	    biglist.remove(biglist[0])
	    j = 0
	    while len(newlist) < target_size:
		if j >= len(biglist):
		    break
		if len(newlist) + len(biglist[j]) > target_size:
		    j = j + 1
		    continue
		newlist = newlist + biglist[j]
		biglist.remove(biglist[j])
	    groups.append(newlist)
	    num_adders = num_addrs - len(newlist)
	lastgroup = []
	for item in biglist:
	    lastgroup = lastgroup + item
	if len(lastgroup):
	    groups.append(lastgroup)
	return groups

    def ContactTranportForEachGroup(sender, groups, file_name):
	for group in groups:
	    if not os.fork():
		ContactTransport(sender,group,file_name)
		os._exit(0)

    sender = sys.argv[2]
    spawns = eval(sys.argv[3])
    file_name = sys.argv[1]
    if spawns > mm_cfg.MAX_SPAWNS:
	spawns = mm_cfg.MAX_SPAWNS
    if spawns < 1:
	spawns = 1
    to_list = sys.argv[4:]

    map(GroupByDomain, to_list)
    final_groups = BuildGroups(domain_info.values(), len(to_list))
    
    ContactTransportForEachGroup(sender, final_groups, file_name)
