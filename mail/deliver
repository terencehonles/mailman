#! /usr/bin/env python
#
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#import sys
#sys.stderr = open("/home/mailman/mailman/logs/debug","a+")
#sys.stdout = sys.stderr
"""Partition a mass delivery into a suitable set of subdeliveries."""

# Heh, heh, heh, this partition reminds me of the knapsack problem ;-)
# Ie, the optimal distribution here is NP Complete.

import os

if not os.fork():
    import string, sys, regsub
    import paths
    import mm_cfg
    def ContactTransport(sender, recip, text):
        cmd = os.path.join(mm_cfg.SCRIPTS_DIR, "contact_transport")
	file = os.popen(string.join([mm_cfg.PYTHON,cmd,sender]+recip," "), 'w')
	file.write(text)
	file.close()
    domain_info = {}
    def GroupByDomain(addr):
        "Collect addrs by major subdomain - e.g. the 'python' in python.org."
	parts = regsub.split(addr, '[.@]')
	key = string.join(parts[-2:])
	if not domain_info.has_key(key):
	    domain_info[key] = [addr]
	else:
	    domain_info[key].append(addr)

    def BuildGroups(biglist, num_addrs):
	biglist.sort(lambda x,y: len(x) < len(y))
	groups = []
	for i in range(spawns-1):
	    target_size = num_addrs / (spawns - i)
	    if not len(biglist):
		break
	    newlist = biglist[0]
	    biglist.remove(biglist[0])
	    j = 0
	    while len(newlist) < target_size:
		if j >= len(biglist):
		    break
		if len(newlist) + len(biglist[j]) > target_size:
		    j = j + 1
		    continue
		newlist = newlist + biglist[j]
		biglist.remove(biglist[j])
	    groups.append(newlist)
	    num_adders = num_addrs - len(newlist)
	lastgroup = []
	for item in biglist:
	    lastgroup = lastgroup + item
	if len(lastgroup):
	    groups.append(lastgroup)
	return groups

    def ContactTransportForEachGroup(sender, groups, text):
	if len(groups) == 1:
            ContactTransport(sender,groups[0],text)
            return
	for group in groups:
	    if not os.fork():
		ContactTransport(sender,group,text)
		os._exit(0)

    sender = sys.argv[2]
    spawns = eval(sys.argv[3])
    file = open(sys.argv[1], "r")
    text = file.read()
    file.close()
    if spawns > mm_cfg.MAX_SPAWNS:
	spawns = mm_cfg.MAX_SPAWNS
    if spawns < 1:
	spawns = 1
    to_list = sys.argv[4:]

    map(GroupByDomain, to_list)
    final_groups = BuildGroups(domain_info.values(), len(to_list))
    ContactTransportForEachGroup(sender, final_groups, text)
    os.unlink(sys.argv[1])
