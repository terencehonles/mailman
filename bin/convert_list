#! /usr/bin/env python
#
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# argv[1] should be the name of the list.
# argv[2] should be the list of non-digested users.
# argv[3] should be the list of digested users.

# Make sure that the list of email addresses doesn't contain any comments,
# like majordomo may throw in.  For now, you just have to remove them manually.

"""Convert a list.

Usage:
    convert_list [-n <file>] [-d <file>] [-h] listname

Where:

    --non-digest-members-file <file>
    -n <file>
        The /etc/aliases style file containing addresses of the members of the
        old list (e.g. it contains one address per line).  This list of people
        become non-digest members.

    --digest-members-file <file>
    -d <file>
        Similar to above, but these people become digest members.


    --help
    -h
        Print this help message and exit.

    listname
        The name of the Mailman list you are converting an old list into.
        It must already exist.

You must supply one or both of -n and -d options.

"""

import sys
import os
import string
import getopt
import paths
import Mailman.MailList
import Mailman.Utils
import Mailman.Message
import Mailman.Errors
import Mailman.mm_cfg


def usage(status, msg=''):
    if msg:
        print msg
    print __doc__ % globals()
    sys.exit(status)


def GetRandomPassword():
    seed1 = Mailman.Utils.GetRandomSeed()
    seed2 = Mailman.Utils.GetRandomSeed()
    return "%s%s" % (seed1, seed2)


def SendExplanation(ml, users):
    msg = Mailman.Message.OutgoingMessage()
    msg.SetSender(ml.GetAdminEmail())
    dict = {'listname'    : ml.real_name,
            'listhost'    : ml.host_name,
            'listaddr'    : ml.GetListEmail(),
            'listinfo_url': ml.GetAbsoluteScriptURL('listinfo'),
            'requestaddr' : ml.GetRequestEmail(),
            'adminaddr'   : ml.GetAdminEmail(),
            'version'     : Mailman.mm_cfg.VERSION,
            }
    header = 'Big change in %(listname)s@%(listhost)s mailing list' % dict
    msg.SetHeader('subject', header)
    msg.AppendToBody(Mailman.Utils.maketext('convert.txt', dict))
    ml.DeliverToList(msg, users, None, None)


def AddMember(ml, addr, digest_p):
    # if the line was empty, just ignore it
    pw = GetRandomPassword()
    try:
        ml.ApprovedAddMember(addr, pw, digest_p)
    except Mailman.Errors.MMAlreadyAMember:
        print 'Already subscribed (skipping):', addr
        
        

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:],
                                   'n:d:h',
                                   ['non-digest-members-file=',
                                    'digest-members-file=',
                                    'help'])
    except getopt.error, msg:
        usage(1, msg)

    if not len(args) == 1:
        usage(1)

    listname = args[0]
    nfile = None
    dfile = None

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-d', '--digest-members-file'):
            dfile = arg
        elif opt in ('-n', '--non-digest-members-file'):
            nfile = arg

    if dfile is None and nfile is None:
        usage(1)

    try:
        ml = Mailman.MailList.MailList(listname)
    except Mailman.Errors.MMUnknownListError:
        usage(1, 'You must first create the list by running: newlist %s' %
              listname)

    try:
        dmembers = []
        if dfile:
            try:
                fp = open(dfile)
                dmembers = filter(None, map(string.strip, fp.readlines()))
                fp.close()
            except IOError:
                pass

        nmembers = []
        if nfile:
            try:
                fp = open(nfile)
                nmembers = filter(None, map(string.strip, fp.readlines()))
                fp.close()
            except IOError:
                pass

        if not dmembers and not nmembers:
            usage(1)

        for member in nmembers:
            AddMember(ml, member, 0)

        for member in dmembers:
            AddMember(ml, member, 1)

        SendExplanation(ml, nmembers + dmembers)
    finally:
        ml.Unlock()

main()
