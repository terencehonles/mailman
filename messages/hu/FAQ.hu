Mailman - The GNU Mailing List Management System
Copyright (C) 1998,1999,2000,2001 by the Free Software Foundation, Inc.
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

GYAKRAN ISMÉTLÕDÕ KÉRDÉSEK

K. Hogyan kell helyesen leírni a program nevét?

V. A "Mailman" elsõ "M" betûjét nagybetûvel kell írni, míg a második
   "m" kicsivel írandó. A "MailMan" írásforma helytelen (mg. felejtsd
   el itt a szótagok kezdõbetûjének nagybetûs írásformáját).

K. A kimenõ leveleket iszonyúan lassan továbbítja a program. Úgy tûnik,
   hogy amikor az MTA valamely címzettnél DNS kérést végez, akkor a
   qrunner nagyon lassan dolgozza fel a várakozási sort. Ötlet?

V. Valójában az MTA DNS kérést végez a címzetteknél, amikor a leveleket
   helyben továbbadja (pl. a Mailman az SMTPDirect.py-el az MTA-nak).
   Ez biza hiba. Ki kell kapcsolnod a géped folyamatos DNS kérését.

   Exim esetén, ez a receiver_verify_hosts megfelelõ beállításával
   történhet. Bõvebb információt a README.EXIM-ben találhatsz.
   Más MTA-k esetében (természetesen) más beállítást kell végrehajtani.
   Elõször olvasd el az MTA-dnak megfelelõ README állományt, majd
   végsõ esetben fordulj az MTA dokumentációjához.

K. A lista tagok a Mailman List-* fejléceirõl kérdezgetnek. Mik 
   ezek valójában?

V. Ezeket a fejlécek a Mailman adja hozza minden egyes kimenõ levélhez,
   a felhasználók kényelmében. A Mailman az RFC 2369-ben foglaltaknak
   megfelelõen hozza létre ezeket a fejléceket. Az RFC 2369 ezeket
   a fejléceket definiálja. Ha még mindig kiváncsiak a felhasználók,
   akkor olvasd el pár jó tanácsért a README.USERAGENT állományt.

K. Hogyan tudom a felhasználó címét megjeleníteni a minden levél
   alján található láblécben?

V. Sehogy. Az oka ennek a hatékonyság. A Mailman a leveleket nem
   egyesével hanem kötegekben továbbítja, így egyszerre nem egy,
   hanem több embernek küldi el azokat. A láblécben a felhasználó címének 
   megjelenítéséhez minden egyes címzettnek egyedi levél kerülne 
   továbbításra, amely elfogadhatatlanul nagy terhelést jelentene a
   rendszerednek.

   Néhány MTA képes ilyen trükkre az ún. VERP (variable envelope
   return path = változtatható válaszcímû levél) technikával. Hogy a
   saját MTA-d képes-e erre arról a beállításainál tudsz meggyõzõdni.

K. A felhasználóim kerülni szeretnék a HTML formátumú leveleket és
   biztonsági okok miatt szeretném a MIME csatolt állományokat is a 
   levelekbõl eltávolítani. Hogyan tehetem ezt meg?

V. A Mailman 2.1 valószínû már támogatni fogja ezt a lehetõséget, de 
   addig külsõ programokat, mint pl. a demime vagy stripmime kell
   használni. Ezekrõl bõvebb információt a következõ oldalakon lehet
   találni:

   (Stripmime) http://www.phred.org/~alex/stripmime.html.

   (Demime)    http://scifi.squawk.com/demime.html.

K. Mi van akkor, ha "document contains no data" (üres dokumentum) 
   üzenetet kapok a webkiszolgálótól, vagy a levelek nem kerülnek fel-
   dolgozásra, vagy "Premature end of script" (hibás szkript befejezés)
   vagy "Mailman CGI error!!!" (Mailman CGI Hiba) üzenetet kapok.

V. A leggyakoribb hibát az okozza, hogy a C wrapper program nem a web-
   kiszolgáló által várt GID jogokkal lett lefordítva. Ugyanilyen
   hibát okoz az is, ha a levelezõrendszer más GID-del hívná meg a
   lefordított C levél wrappert.

   A hiba elhárításához újra kell fordítani a Mailman-t a --with-cgi
   -gid és --with-mail-gid kapcsolókkal. Az INSTALL állományban errõl
   bõvebben lehet olvasni.

   Ezek a hibaüzenetek nem a Mailman naplóállományaiban, hanem a
   rendszerszintû naplóállományokban jelennek meg. A CGI wrappernél
   felmerülõ hibák közvetlenül a web böngészõben jelennek meg, a
   szükséges GID-del együtt. Ez nagyban tud segíteni.

   A syslog-ot be lehet állítani, hogy pl. a mail.error hibákat egy
   megadott állományba naplózza; például Solaris rendszeren a

       mail.debug                /var/log/syslog

   sor azt jelenti, hogy az üzenetek a /var/log/syslog állományba
   kerülnek. (A rendszerhez tartozó syslog.conf állomány mondja meg
   (ha van), hogy az üzenetek hova kerüljenek. A syslog man-jában
   errõl bõvebb információ található.)

   Ha a rendszered így van beállítva és a mailman/listinfo lap meg-
   tekintésénél UID vagy GID hiba merül fel, akkor a /var/log/syslog
   állományban megtalálható a jelenlegi és a szükséges UID/GID érték.

K. Miért 'fagynak' le a weboldalak?

V. Az ok, hogy a CERN típusú webszerek a Python folyamatokat futási
   állapotban hagyhatják, ezzel lefagyaszthatják a CGI-ket. Ezen esetben
   nincs más, mint használj inkább Apache-ot.

   Elõfordulhat, hogy lejárt zárolások vannak jelen. Mailman az adat-
   bázisának biztonsága érdekében szigorúan veszi a zárolást, de
   néha rendszerhibák következtében lejárt zárolások lehetnek jelen.
   A $prefix/locks könyvtárban találhatóak a zároló állományok (hogy
   lejárt-e valamilyek zárolás, az könnyen megállapítható, ha egy
   ps parancssal megnézzük, hogy az állományban található folyamat-
   azonosítóhoz (PID) tartozik-e futó folyamat, ha nem akkor nyugodtan
   lehet törölni a zároló állományt.) 

K. Mit kell idõnként megnéznem?

V. A szkriptek többsége a ~mailman/logs/error állományba jegyzi be
   hibaüzeneteit, így alkalmanként ebben kell keresnünk hibára utaló 
   üzenetet.

   Az állományban *nem* találhatóak meg a szintaxis hibára vonatkozó
   üzenetek, mivel ezek az installálás során azonnal kibuknak, a .py
   állományok fordításánál. Szintaxis hibák a forrás nem megfelelõ 
   módosításánál, vagy olyan szkriptekben, amelyek nem modulok
   fordulhatnak elõ.

   A `compile' vagy `compileall' Python modulokkal bármikor le lehet
   bájtonként fordítani egy állományt, vagy egyszerûen a Python
   értelmezõ segítségével a modult betölteni és tesztelni.

K. Miért nem mûködik az archívum?

V. A listára érkezett már levél? Ez egy ismert hiba; az archívum addig
   nem mûködik amíg legalább egy levél nem érkezett a listára.

K. Okés, az archívum mûködne, de mégsem tudom a nyilvános archívumot
   elérni. Miért?

V. Apache esetén gyõzõdjünk meg, hogy a FollowSymlinks a nyilvános
   archívum útvonalára is meg van-e adva. Fontos tudni, hogy az archívum
   mindig a privát könyvtárban található; nyilvános archívumnál
   mindössze egy hivatkozás mutat a privát archívumra. Bõvebb
   információ olvasható a következõ címen:

   http://mail.python.org/pipermail/mailman-users/1998-November/000150.html

K. Még mindig nem megy? QMail-t használok!

V. Gyõzõdjünk meg róla, hogy a "wrapper" program meghívásánál a
   "preline" meg van adva:

       |preline /home/mailman/mail/wrapper post listname

   A "preline" használatával egy Unix-típusú "From " fejléc jön létre a
   levelekben, amelyek az archiváláshoz szükségesek. Az archívum mbox
   állományában lévõ minden üzenetbe a következõ sort beszúrva

       From somebody Mon Oct  9 12:27:34 MDT 2000

   megoldódik a probléma. Futtassuk újra a "bin/arch listaneve" parancsot.
   Az archívumnak most már létre kell jönnie. További információt a
   README.QMAIL állományban lehet olvasni.

K. Még mindig nem megy? GNU/Linux-ot használok!

V. Olvassa el a README.LINUX állományt.

K. Az archívumból szeretnék pár levelet törölni. Hogyan tehetem ezt
   meg?

V. David Rocher megoldása:

   * törölje a $prefix/archives/private/<listaneve> könyvtárat
   * szerkesztõvel módosítsa a következõ állományt:
     $prefix/archives/private/<listanave>.mbox/<listaneve>.mbox
   * futtassuk a $prefix/bin/arch <listaneve>  parancsot

K. Igenre állítottam a "member_posting_only" (csak_tagok_küldhetnek)
   beállítást, hogy csak a listatagok küldhessenek levelet a listára,
   azonban úgy néz ki, hogy a listatagoktól érkezõ összes levél
   engedélyezésre vár a megjelenéshez. Miért?

V. Egyes rendszereken a levél feladója (pl. a Unix "From " sor) hibás
   lehet. Ekkor a Mailman a feladót nem tudja listatagként azonosítani.
   1.0b12-es verzióig a Mailman alapesetben elõbb a levél feladóját 
   és nem a From: mezõben található feladót keresi meg, mivel az
   elõbbit az SMTP program tölti ki, míg utóbbinak a felhasználó akár
   bármit megadhat.

     [ A levél feladójának megváltoztatásából adódó hibák gyakran elõ-
     fordulnak, de a sendmail "owner-alias" szolgáltatásról illik pár
     szót ejteni itt:

     Ha egy levél érkezik a "foo" listára, és az "owner-foo"  alias
     is meg van adva, akkor a levél feladója egyszerûen "owner-foo"-
     ként lesz azonosítva.

     A Mailman 1.0rc2 verziójától fogva már megfelelõen dolgozza fel
     ezt a (nem változtatható) sendmail-es problémát. Régebbi verziók
     esetében megoldást jelenthet az, ha az ajánlott "owner-LISTNAME"
     sort kihagyjuk minden egyes Mailman listánál az alias állományból.

   Azonban ilyen probléma esetén biztosabb megoldást jelent, ha a
   From: fejlécet használjuk a levél feladójaként beállított helyett.
   Ehhez az mm_cfg.py állományba kell a következõ sort elhelyezni:

   USE_ENVELOPE_SENDER=0

   Ha még (vitathatóbb) biztonságra akarunk törekedni akkor az
   mm_cfg.py állományba a következõt írjuk be:

   USE_ENVELOPE_SENDER=1

   Azonban olvassuk el a Defaults.py-ben található leírásokat a
   változóról. Alapesetben a 2.0-s Mailman a From: fejlécet használja
   fel cím azonosításhoz.

K. Mennyire biztonságos a Mailman web azonosítási módszere?

V. Ha a Mailmant SSL-re képes web kiszolgálóra telepítettük (pl.
   a Mailman weblapokat "https://..." címeken érjük el), akkor annyira
   biztonságos az azonosítás, amennyire az SSL kapcsolat.

   Azonban a legtöbb Mailman telepítés hagyományos, titkosítás nélküli
   kiszolgálókra történik. Ezzel legtöbbnyire nem nincs gond, azonban
   egy felkészült cracker azonosítás nélkül is képes *lehet* adatokhoz
   hozzáférni a következõ módokon:

   * Kapcsolat lehallgatása: A nem nyilvános Mailman lapokon használt 
     azonosításnál a jelszavak sima szöveges formátumban kerülnek
     elküldésre. Ha ezt el akarjuk kerülni, akkor használjunk SSL-re
     képes kiszolgálót.

   * Érvényes süti ellopása: Sikeres bejelentkezés után a Mailman
     egy sütit küld vissza a felhasználóhoz. A süti a további védett
     oldalakhoz segít az azonosításban. A Mailman "kapcsolatra érvényes
     sütiket" (session cookies) használ, amelyek a böngészõ bezárásával,
     vagy kilépés gombra kattintva lejárnak.

     A felhasználó sütijének megszerzésével (pl. a felhasználó 
     böngészõjének sütiket tartalmazó adatbázisának olvasásával, vagy
     a kapcsolat lehallgatásával, vagy akár olyan hibás böngészõ
     használatával, amely a felhasználó összes sütijét nyilvánossá teszi)
     és a többi szükséges feltétel egy idõben való használatával 
     jogosulatlan hozzáféréshez lehet jutni.

     Fontos tudnunk, hogy ez a módszer könnyebben felhasználható, ha 
     a felhasználó proxi mögött helyezkedik el, mivel ekkor a süti
     minden az adott proxin átmenõ kapcsolatra érvényes lesz, nem csak 
     arra melyet a felhasználó kezdeményezett.

   * Hozzáférés a felhasználó termináljához: Ez is egy süti lopó
     módszer. Azonban ezt a sütik rövid élettartama nehezíti meg.
     Fogjuk fel annak, hogy a kényelemért meg kell elégednünk a 
     csökkentett biztonságért, különben minden pillanatban gépelhetjük
     be a jelszavunkat.

K. Hogyan tudom a listát átnevezni?

V. A listál átnevezése jelenleg még elég bonyolult mûvelet, fõleg ha
   azt szeretnénk, hogy a régi hivatkozások is éljenek. A jövõben ezen
   majd változtatni fogunk. :(

   A legnagyobb problémát az okozhatja, hogy a lista átnevezése közbeni
   levélforgalmat, hogyan lehet biztonságosan szüneteltetni. Teljesen
   biztonságos módszer nincsen, de a következõkben leírtakkal nagyban
   lehet csökkenteni a hibalehetõséget:


   - Átmenetileg állítsuk le a qrunnert. Ehhez a mailman crontab 
     bejegyzését kell módosítani. Adjuk ki a következõ parancsot és
     tegyünk minden sor elé megjegyzés jelet ('#'). Mentsük el a 
     változásokat és lépjünk ki a szerkesztõbõl.

     % crontab -u mailman -e

   - Állítsuk le a levelezõszervert. A legtöbb esetben ez nem fog gondot
     okozni, mivel a távoli MTAk addig próbálkoznak a levél kézbesítésével,
     amíg a rendszer át nem veszi, s mi nem sok ideig fogjuk a rendszert
     feltartani.

   - Állítsuk le a webszervert is, ha lehetséges. Ez természetesen azt
     jelenti, hogy nem lesz elérhetõ semmelyik weboldalunk, ez lehet
     hogy nem szeretnénk. Következõ hasznos dolog lesz majd egy állandó 
     átirányítás alkalmazása a régi listáról. Ez azt jelenti, hogyha
     bárki a régi lista oldalára látogat el, akkor az átiránytás az új 
     listára teszi át, amíg a lista átnevezésével nem végeztünk addig
     az átirányítás sem fog mûködni.

     Tegyük fel, hogy "oldname" listát átnevezzük "newname" listává. Ekkor
     a következõ Apache parancsokat kell használnunk:

     RedirectMatch permanent /mailman/(.*)/oldname(.*) http://www.dom.ain/mailman/$1/newname$2
     RedirectMatch permanent /pipermail/oldname(.*)    http://www.dom.ain/pipermail/newname$1

     Ezeket a sorokat a httpd.conf állományba kell elhelyezni, indítsuk
     újra az Apache-ot.
   
   - Ezek után váltsunk a telepített Mailman könyvtárba. Esetünkben
     legyen ez a /usr/local/mailman könyvtár:

     % cd /usr/local/mailman

     menjünk a 'lists' környvtárba:

     % cd lists

     Itt találunk egy 'oldname' könyvtárat. Nevezzük át 'newname'-é:

     % mv oldname newname

   - Most menjünk a privát archívum könyvtárába:

     % cd ../archives/private

     Az oldname .mbox könyvtárát és a benne található állományokat át
     kell neveznünk. Most még ne törödjünk a nyilvános archívum ide- 
     mutató hivatkozásaival, késöbb azokról is gondoskodunk:

     % mv oldname.mbox newname.mbox
     % mv newname.mbox/oldname.mbox newname.mbox/newname.mbox

   - Mostmár futtathatjuk a 'bin/move_list' programot az archívum elérési
     útjainak frissítéséhez. FONTOS: ha Mailman 2.1-et használunk, akkor
     hagyjuk ki ezt a lépést!

     % cd ../..
     % bin/move_list newname

   - Hozzuk újra létre a nyilvános archívumot:

     % bin/arch newname

   - Ezek után néhány lista beállítást is meg kell változtatni, hogyha
     szeretnénk a régi listára küldött leveleket az új listán látni. Menjünk
     az új lista adminisztárciós oldalára:

     o General options beállítások

     o A "real_name" résznál adjuk meg a lista új nevét, pl. "Newname"

     o Adjuk meg a level tárgysorába beszúrandó részt (prefix),
       pl. "[Newname] " (igen, fontos a szóköz a végénÖ.

     o Ha szükséges változtassuk meg más beállításokat is, mint például
       a list rövid leírása, üdvzölõ szövege, stb.

     o Mentsük el a változtatásokat.

     o Privacy options rész

     o Adjuk az acceptable_aliases részhez a régi lista címét. 
       Pl. "oldname@dom.ain" Ezzel (ha a késõbb leírt /etc/aliases 
       módosítást is elvégezzük) a régi listára küldött levelek nem
       fognak szerkesztõi jóváhagyásra várni "implicit destination"
       hibával.

     o Mentsük el a változtatásokat.

   - Nos, most frissítsuk az /etc/aliases állományunkat, hogy fogadja az
     új list leveleit és átküldje a régi címre küldött levelekt. Azt
     itt leirtak Sendmail típusú alias állományhoz vannak, eltérõ MTA
     esetén lehet hogy módosítani kell rajtuk.

     o Keressük meg a régi listához tartozó alias sort.

     o Jelöljök ki és másoljuk és közvetlenül a régi alá a sorokat.

     o Az átmásolt részben minden "oldname" részt írjuk át "newname"-é.

     o Most változtassuk meg a régi listához tartozó címeket, hogy azok
       az új lista megfelelõ címeire mutassanak. Ha mindezt jól csináltuk,
       akkor a következõhöz hasonlót kell kapnunk:

       # A régi listát átirányítottuk az új címére
       oldname:         newname@dom.ain
       oldname-request: newname-request@dom.ain
       oldname-admin:   newname-admin@dom.ain
       oldname-owner:   newname-owner@dom.ain

       newname:         "|/usr/local/mailman/mail/wrapper post newname"
       newname-admin:   "|/usr/local/mailman/mail/wrapper mailowner newname"
       newname-request: "|/usr/local/mailman/mail/wrapper mailcmd newname"
       newname-owner:   newname-admin

     o Futassuk a 'newaliases' programot.

   - Mielõtt mindent újraindítanánk nézzük meg, hogy van-e a qfiles/
     könyvtárban a régi listára küldött, de még nem továbbított levél. 
     Ezt a következõképen tehetjük meg:

     % cd /usr/local/mailman/qfiles
     % grep oldaname *.msg

     Ha nincs találat, akkor ugarhatunk a következõ lépésre, egy gonddal
     kevesebb.

     Ha van találat, akkor izzadni fogunk egy kicsit. Figyelmeztetlek,
     hogy a következõ lépések nem lettek teljeskörûen letesztelve. :(

     A régi listára küldött minden egyes .msg állománynál a hozzátartozó
     .db állományt kell módosítani. Sajnos ez nem egy könnyû menet.
     No lássuk...

     Mentsük el a következõ Python kód részletet 'hackdb.py' névvel:

     -------------------------hackdb.py
     import sys
     import marshal
     fp = open(sys.argv[1])
     d = marshal.load(fp)
     fp.close()
     d['listname'] = sys.argv[2]
     fp = open(sys.argv[1], 'w')
     marshal.dump(d, fp)
     fp.close()
     -------------------------

     Adjuk ki azokon az állományokon a következõ parancsot, amelyekre
     a grep találatot jelzett.

     % python hackdb.py nagyonhosszuhexafilenev1.db newname

   - Ezek után indítsuk el az MTA-t.

   - Tegyük újra üzembe a qrunner-t.

     % crontab -u mailman -e

     Vegyük ki a megjegyzés jeleket azon sorok elõl, ahova mi tettük
     azokat. Mentsük el a változtatásokat és lépjünk ki a szerkesztõbõl.

   - Döljünk hátra és örüljünk mert megcsináltuk az átnevezést. Ha 
     100.000 $-al támogatod a Mailman fejlesztõgárdáját, akkor igérjük,
     hogy legközelebb sokkal könnyebb lesz a listák átnevezése. :)
							    
    
Local Variables:
mode: text
indent-tabs-mode: nil
End:
